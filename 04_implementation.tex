\section{Opis implementacije praktičnog rada}

\subsection{Instalacija i konfiguracija okruženja}

\subsubsection{Početni komplet Laravel Jetstream}
Kako bi \textit{developerima} uštedio vrijeme u samome početku razvijanja nove aplikacije, Laravel nudi autentikacijske i aplikacijske početne komplete (engl.~\textit{starter kits}) kao što su Laravel Breeze i Laravel Jetstream koji automatski pružaju rute, kontrolere i poglede (engl. \textit{views}) potrebne za registraciju i autentikaciju~\cite{starterKits}.

Laravel Jetstream dizajniran je koristeći \textbf{Tailwind CSS}, \textit{utility-first} CSS razvojni okvir. Datoteke \texttt{postcss.config.js} i \texttt{tailwind.config.js} koriste se pri \textit{buildanju} kompajliranog CSS-a aplikacije.

Značajke koje početni komplet Laravel Jetstream pruža su autentikacija, registracija, upravljanje korisničkim profilima, ponovno postavljanje lozinke, verifikacija e-adrese, dvostruka provjera autentičnosti (engl. \textit{two-factor authentication}), upravljanje aktivnim sesijama u web preglednicima, API podrška te opcionalne opcije za upravljanje timovima~\cite{jetstreamIntro}.

Instalira se koristeći Composer, a naredbe za instalaciju prikazane su u ispisu~\ref{jetstreamInstallation}.

\begin{lstlisting}[caption={Naredbe za instalaciju Jetstream paketa u novi Laravel projekt}, label=jetstreamInstallation]
composer create-project laravel/laravel teamstructor-app

cd teamstructor-app

composer require laravel/jetstream
\end{lstlisting}

Jetstream pruža izbor između korištenja \textbf{Livewire} ili Inertia.js \textit{frontend scaffoldinga}. O tom izboru ovisi i odabrani jezik za predloške (engl. \textit{templating language}) jer uz Livewire to je \textbf{Blade}, a uz Inertia.js to je Vue.js~\cite{jetstreamIntro}. \\ Za instaliranje Jetstreama s Livewire \textit{frontend scaffoldingom} i to s uključenom podrškom za timove koristi se naredba \\ \texttt{php artisan jetstream:install livewire -{}-teams}~\cite{jetstreamInstallation}.

\texttt{php artisan vendor:publish -{}-tag=jetstream-views} je naredba čijim se izvršavanjem u \texttt{app} direktoriju kreira direktorij \texttt{resources/view/components} koji sadrži razne generičke Blade komponente čija je svrha da ih se jednostavno može koristiti te pružanje konzistentnog korisničkog sučelja bez potrebe da \textit{developer} kreira vlastite komponente~\cite{jetstreamLivewire}.

Nakon instalacije Jetstreama potrebno je instalirati i pokrenuti \textit{build} NPM ovisnosti pomoću naredbi \texttt{npm install} i \texttt{npm run build} te migrirati bazu naredbom \texttt{php artisan migrate}~\cite{jetstreamInstallation}.

\subsubsection{\texttt{.env} datoteka}
\texttt{.env} datoteka nalazi se u aplikacijskom \textit{root} direktoriju i služi kao konfiguracijska datoteka za Laravel web aplikaciju. Pri instalaciji Laravela kreirana je tako da se u nju kopira ogledna konfiguracijska datoteka \texttt{.env.example}~\cite{configuration}. 

Dobra je praksa i zbog sigurnosti i zbog toga što je konfiguracija promjenjiva ovisno o pojedinačnim okruženjima da neenkriptirana \texttt{.env} datoteka nije dio kontrole izvornog k\^oda aplikacije, dok je to u redu za \texttt{.env.example} datoteku te ista može poslužiti kao ogledni primjer s \textit{placeholder} vrijednostima za varijable koje je potrebno definirati~\cite{configuration}.

Primjer definicije varijable može se vidjeti u ispisu~\ref{envDefinition}.

\begin{lstlisting}[caption={Definicija varijable u \texttt{.env} datoteci}, label=envDefinition]
APP_NAME=Teamstructor
\end{lstlisting}

U Laravel aplikaciji pristup vrijednosti pojedine varijable iz \texttt{.env} datoteke moguć je pomoću \texttt{\$\_ENV} PHP superglobalne varijable ili koristeći funkciju \texttt{env}, kao u ispisu~\ref{envRetrieve}.

\begin{lstlisting}[caption={Pristup vrijednosti \textit{environment} varijable u Laravelu}, label=envRetrieve]
'name' => env('APP_NAME', 'Laravel'),
\end{lstlisting}

\subsection{Struktura Laravel aplikacije}

\subsubsection{Struktura početnog direktorija s izvornim k\^odom aplikacije}
Osnovna struktura \textit{root} direktorija Laravel aplikacije jest sljedeća~\cite{structure}:  \\
\dirtree{%
.1 teamstructor-app.
.2 app.
.2 bootstrap.
.2 config.
.2 database.
.2 node\_modules.
.2 public.
.2 resources.
.2 routes.
.2 storage.
.2 tests.
.2 vendor.
}

\begin{itemize}
\item \texttt{app} - Sadrži "jezgru" aplikacije te će biti posebno predstavljen u poglavlju~\ref{subsubsection:app}.
\item \texttt{bootstrap} - Sadrži datoteku \texttt{app.php} koja pokreće razvojni okvir te direktorij \texttt{cache} koji sadrži datoteke predmemorije za optimizaciju performansi.
\item \texttt{config} - Sadrži konfiguracijske datoteke.
\item \texttt{database} - Sadrži migracije, tvornice modela (engl. \textit{model factories}) i \textit{seed}-ove.
\item \texttt{node\_modules} - Nije u osnovnoj strukturi, međutim nastaje instalacijom NPM ovisnosti te sadrži instalirane module tj. biblioteke potrebne za \textit{frontend} dio aplikacije kao poddirektorije.
\item \texttt{public} - Sadrži datoteku \texttt{index.php} koja je polazna točka svih zahtjeva prema aplikaciji te konfigurira automatsko učitavanje (engl. \textit{autoloading}).  Također se tu nalaze i javna "imovina" aplikacije (engl. \textit{assets}): slike te JavaScript i CSS datoteke.
\item \texttt{resources} - Sadrži poglede (engl. \textit{views}) i nekompajlirane JavaScript i CSS datoteke koje su \textit{assets} aplikacije.
\item \texttt{routes} - Sadrži definicije svih ruta u aplikaciji. Zadano su uključene datoteke: \texttt{web.php}, \texttt{api.php}, \texttt{console.php} i \texttt{channels.php}.
\item \texttt{storage} - Služi kao lokalno spremište podataka aplikacije te je podijeljen na direktorije \texttt{app}, \texttt{framework} i \texttt{logs}. Sadrži \texttt{.log} datoteke zapisnika, kompajlirane Blade predloške, sesije, predmemorije datoteka itd.
\item \texttt{tests} - Sadrži skripte za automatizirane aplikacijske testove te dolazi s po jednim oglednim primjerom \textit{unit} i \textit{feature} testova.
\item \texttt{vendor} - Sadrži preuzete Composer ovisnosti aplikacije.
\end{itemize}

\subsubsection{Struktura \texttt{app} direktorija}
\label{subsubsection:app}
Na slici~\ref{fig:appDir} prikazan je sadržaj \texttt{app} direktorija.
\begin{figure}[H]
	\includegraphics[width=0.4\linewidth,clip=]{assets/app-directory.png}
	\centering
	\caption{Sadržaj \texttt{app} direktorija}
	\label{fig:appDir}
\end{figure}

Može se vidjeti da se \texttt{app} direktorij sastoji od sljedećih poddirektorija~\cite{structure}: 
\begin{itemize}
\item \texttt{Actions} - Direktorij koji se kreira pri Jetstream instalaciji, a sadrži \texttt{Action} klase koje obično izvode samo jednu akciju i odgovaraju jednoj Jetstream ili Fortify značajki kao npr. kreiranje korisnika ili tima,  postavljanje nove lozinke, brisanje korisnika ili tima, dodavanje člana u tim itd.~\cite{jetstreamActions}
\item \texttt{Console} - Sadrži datoteku \texttt{Kernel.php} u kojoj se registriraju \textit{custom} Artisan naredbe.
\item \texttt{Exceptions} - Sadrži datoteku \texttt{Handler.php} koja upravlja svim iznimkama u aplikaciji te je moguće registrirati nove \textit{custom} iznimke.
\item \texttt{Http} - Gotovo sva logika aplikacije smještena je u ovaj direktorij. Sadrži kontrolere, klase Livewire komponenti te \textit{middleware}.
\item \texttt{Models} - Sadrži klase svih Eloquent modela ove web aplikacije.
\item \texttt{Policies} - Nastaje izvođenjem \texttt{make:policy} Artisan naredbe te sadrži klase u kojima su definirana pravila autorizacije unutar aplikacije.
\item \texttt{Providers} - Sadrži sve davatelje usluga (engl. \textit{service providers}) aplikacije.
\item \texttt{View} - Direktorij se kreira pri Jetstream instalaciji, a sadrži klase Livewire \textit{layout} komponenti - "application" \textit{layout} te "guest" \textit{layout}~\cite{jetstreamLayouts}.
\end{itemize}

Još nekolicina direktorija može biti generirana unutar \texttt{app} direktorija izvršavanjem Artisan \texttt{make} naredbi za generiranje klasa~\cite{structure}. 

\subsection{Struktura relacijske baze podataka}
Na slici~\ref{fig:erDiagram} prikazan je ER (engl. \textit{Entity Relationship}) dijagram relacijske baze podataka u phpMyAdmin sučelju na kojemu se može vidjeti tablice u koje su podatci spremani te njihove međusobne relacije.
\begin{figure}[H]
	\includegraphics[width=1\linewidth,clip=]{assets/db-er-diagram.png}
	\centering
	\caption{Dijagram relacijske baze podataka}
	\label{fig:erDiagram}
\end{figure}

Radi preglednosti su na dijagramu sa slike~\ref{fig:erDiagram} prikazane samo tablice koje se odnose na modele, a izostavljene su tablice: 
\begin{itemize}
\item \texttt{failed\_jobs} - Automatski prisutna u Laravel aplikacijama, služi za pohranu poslova iz reda čekanja koji se nisu uspjeli izvršiti.
\item \texttt{migrations} - Automatski prisutna u Laravel aplikacijama, služi za pohranu migracija.
\item \texttt{password\_reset\_tokens} - Automatski prisutna u Laravel aplikacijama, služi za pohranu tokena za ponovno postavljanje lozinki u aplikaciji.
\item \texttt{personal\_access\_tokens} - Kreira je Laravel Sanctum pri instalaciji Laravel Jetstreama, a služi za pohranu API tokena u aplikaciji.
\item \texttt{sessions} - Kada se koristi \texttt{database} \textit{driver} za sesije, onda se u ovu tablicu one pohranjuju.
\item \texttt{telescope\_entries}, \texttt{telescope\_entries\_tags}, \\ \texttt{telescope\_monitoring} - Nastaju pri instalaciji Laravel Telescopea, a služe za pohranu podataka za Telescope.
\end{itemize}

U poglavlju~\ref{subsection:dbInteraction} će biti više rečeno o načinima na koje se ostvaruje interakcija s bazom podataka te o samim modelima i relacijama.

\subsection{Interakcija s bazom podataka}
\label{subsection:dbInteraction}

\subsubsection{Migracije}
Migracije služe kao kontrola verzije baze podataka. U Laravelu migracije koriste fasadu (engl. \textit{facade}) \texttt{Schema} koja pruža \textit{database agnostic} podršku za sve sustave baza podataka koje Laravel podržava~\cite{migrations}.

Migracija se može kreirati pozivom \texttt{make:migration} Artisan naredbe te će se ista smjestiti u \texttt{database/migrations} direktorij. Nazivu svake migracije dodaje se pripadajući \textit{timestamp} prema kojem Laravel prati redoslijed migracija~\cite{migrations}.

Sama migracijska klasa sadrži dvije metode: \texttt{up} koja kreira ili modificira tablice, stupce ili indekse u bazi podataka te \texttt{down} koja bi trebala poništiti promjene učinjene u \texttt{up} metodi inverznim operacijama~\cite{migrations}.

U ispisu~\ref{projectsTableMigration} može se vidjeti k\^od migracije za kreiranje tablice \texttt{projects} u kojoj se u \texttt{up} metodi kreira tablica navodeći njezin naziv i stupce koje sadrži, a u \texttt{down} metodi poništavaju operacije izvedene u \texttt{up} metodi na način da se odbacuje novokreirana tablica tj. izvodi \textit{drop} tablice.

\begin{lstlisting}[caption={Migracija za kreiranje tablice \texttt{projects}}, label=projectsTableMigration]
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('projects', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->text('description');
            $table->foreignId('team_id')->constrained();
            $table->foreignId('user_id')->constrained();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('projects');
    }
};

\end{lstlisting}

U ispisu~\ref{administratorColumnMigration} prikazana je migracija koja modificira tablicu \texttt{users} tako da joj dodaje stupac \texttt{is\_administrator}. U \texttt{up} metodi definira se stupac koji će se dodati, a u \texttt{down} metodi te će promjene biti poništene odbacivanjem novododanog stupca metodom \texttt{dropColumn}.

\begin{lstlisting}[caption={Migracija za dodavanje stupca \texttt{is\_administrator} u tablicu \texttt{users}}, label=administratorColumnMigration]
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('users', function (Blueprint $table) {
            $table->boolean('is_administrator')->default(false);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('users', function (Blueprint $table) {
            $table->dropColumn('is_administrator');
        });
    }
};

\end{lstlisting}

Za izvršiti sve migracije koje se još nisu primijenile na bazu podataka pokreće se Artisan naredba \texttt{migrate}, a za povratak na prethodnu migraciju tj. poništavanje promjena posljednjih \textit{n} migracija Artisan naredba \texttt{migrate:rollback}~\cite{migrations}.

\subsubsection{Populacija podatcima}
Populacija baze podataka (engl. \textit{seeding}) u Laravelu se može obaviti koristeći \textit{seed} klase koje se nalaze u direktoriju \texttt{database/seeders}. Ondje se zadano nalazi \\ \texttt{DatabaseSeeder} klasa koja sadrži metodu \texttt{run} koja se izvršava pozivom \texttt{db:seed} Artisan naredbe. Unutar metode \texttt{run} koristeći se metodom \texttt{call} pozivaju se dodatni ostali u aplikaciji definirani \textit{seederi}. Dobra je praksa \textit{seeding} k\^od podijeliti u više dijelova tj. \textit{seed} klasa jer se tako ne "zatrpava" isključivo jedan \textit{seeder} k\^odom. U ispisu~\ref{databaseSeeder} može se vidjeti \textit{seedere} pozvane koristeći metodu \texttt{call}~\cite{seeding}.

\begin{lstlisting}[caption={Sadržaj \texttt{DatabaseSeeder} klase}, label=databaseSeeder]
<?php

namespace Database\Seeders;

// use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     */
    public function run(): void
    {
        $this->call([
            UserSeeder::class,
            TeamSeeder::class,
            ProjectSeeder::class,
            PostSeeder::class,
            CommentSeeder::class,
            ResourceSeeder::class,
        ]);
    }
}

\end{lstlisting}

Samo ubacivanje podataka u bazu podataka koristeći \textit{seedere} može se ostvariti ručno koristeći \textit{query builder} ili koristeći Eloquent tvornice modela (engl. \textit{model factories}) o čemu će biti više riječi u nastavku.

\subsubsection{Eloquent ORM}
Eloquent ORM (engl. \textit{object-relational mapper}) je Laravelova biblioteka za objektno-relacijsko mapiranje čija je uloga olakšati interakcije s bazom podataka jer obavlja konverziju k\^oda napisanog u objektno orijentiranom jeziku u jezik relacijske baze podataka i obrnuto. Omogućava stvaranje virtualne objektne baze podataka koja je prilagođena korištenju unutar programskog jezika~\cite{eloquent}.

\paragraph{Modeli i tvornice modela}\mbox{}\\
\indent Eloquent modeli nalaze se u direktoriju \texttt{app/Models} te se za stvaranje novog modela koristi Artisan naredba \texttt{make:model}. Svaka tablica baze podataka odgovara jednom Eloquent modelu te će on biti korišten za operacije nad istom. Prema konvenciji, ako drugačije nije definirano u samoj klasi, naziv odgovarajuće tablice je naziv klase modela u množini u \textit{snake caseu}. Tako su u tablici~\ref{fig:namingModelTable} prikazani nazivi klasa modela te odgovarajući nazivi tablica (koje su prikazane i na slici~\ref{fig:erDiagram}).

\begin{longtable}{ll}
\caption{Nazivi klasa modela i pripadajuće tablice}\label{fig:namingModelTable}
\endfirsthead
\endhead
\hline
Naziv klase modela&Naziv odgovarajuće tablice\\
\hline
\lstinline!Comment!&comments\\
\lstinline!Membership!&team\_user\\
\lstinline!Post!&posts\\
\lstinline!Project!&projects\\
\lstinline!Resource!&media\\
\lstinline!Team!&teams\\
\lstinline!TeamInvitation!&team\_invitations\\
\lstinline!User!&users\\
\hline
\end{longtable}

U klasi modela definiraju se njegovi atributi (\textit{fillable} - one koji su \textit{mass assignable} tj. dozvoljeno je da ih dodijele korisnici aplikacije te \textit{hidden} - one koji su skriveni pri serijalizaciji), relacije (o kojima će biti više riječi u poglavlju~\ref{paragraph:relations}), \textit{traits} tj. osobine koje koristi, događaje koje emitira itd.

U ispisu~\ref{modelUser} prikazan je dio k\^oda iz klase modela \texttt{User} gdje je vidljivo da koristi nekolicinu osobina (engl. \textit{traits}) te definiranje atributa modela.

\begin{lstlisting}[caption={Dio k\^oda model klase \texttt{User}}, label=modelUser]
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Fortify\TwoFactorAuthenticatable;
use Laravel\Jetstream\HasProfilePhoto;
use Laravel\Jetstream\HasTeams;
use Laravel\Sanctum\HasApiTokens;

class User extends Authenticatable
{
    use HasApiTokens;
    use HasFactory;
    use HasProfilePhoto;
    use HasTeams;
    use Notifiable;
    use TwoFactorAuthenticatable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'name', 'email', 'password',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array<int, string>
     */
    protected $hidden = [
        'password',
        'remember_token',
        'two_factor_recovery_codes',
        'two_factor_secret',
        'is_administrator',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
    ];

    /**
     * The accessors to append to the model's array form.
     *
     * @var array<int, string>
     */
    protected $appends = [
        'profile_photo_url',
    ];
    
// ...
\end{lstlisting}

U ispisu~\ref{modelUser} može se primjetiti da model \texttt{User} koristi osobinu \texttt{HasFactory}. Pomoću tvornica modela (engl. \textit{model factories}) može se definirati skup zadanih atributa za određeni Eloquent model pa je olakšano populiranje baze podataka sa testnim zapisima. Tvornica modela može se generirati Artisan naredbom \texttt{make:factory} te će se nalaziti u \texttt{database/factories} direktoriju~\cite{factories}.

U ispisu~\ref{factoryUser} prikazan je dio k\^oda iz tvornice modela \texttt{UserFactory} gdje je vidljiva metoda \texttt{definition} koja vraća skup atributa koji bi se trebali primijeniti na model pri njegovom kreiranju. Za generiranje testnih lažnih podataka koristi se Faker~\cite{fakerGitHub} PHP biblioteka čija je instanca u \texttt{\$this->faker}~\cite{factories}.

\begin{lstlisting}[caption={Dio k\^oda tvornice modela \texttt{UserFactory}}, label=factoryUser]
<?php

namespace Database\Factories;

use App\Models\Team;
use App\Models\User;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Str;
use Laravel\Jetstream\Features;

class UserFactory extends Factory
{
    /**
     * The name of the factory's corresponding model.
     *
     * @var string
     */
    protected $model = User::class;

    /**
     * Define the model's default state.
     *
     * @return array<string, mixed>
     */
    public function definition(): array
    {
        return [
            'name' => $this->faker->name(),
            'email' => $this->faker->unique()->safeEmail(),
            'email_verified_at' => now(),
            'password' => '...', // password
            'two_factor_secret' => null,
            'two_factor_recovery_codes' => null,
            'remember_token' => Str::random(10),
            'profile_photo_path' => null,
            'current_team_id' => null,
            'is_administrator' => false,
        ];
    }
    
// ...
\end{lstlisting}

Također, tvornicama modela mogu se definirati stanja (engl. \textit{factory states}) koja predstavljaju način da se primijene diskretne izmjene tj. modificiraju atributi na nekoj tvornici modela. U ispisu~\ref{factoryStatesUser} prikazan je dio k\^oda iz tvornice modela \texttt{UserFactory} gdje se definira stanje tvornice modela za stvaranje administrator korisnika. Vidljivo je da to stanje vrši izmjene samo na odabranim atributima, a ostali će atributi biti postavljeni kao u izvornoj definiciji tvornice modela~\cite{factories}.

\begin{lstlisting}[caption={Dio k\^oda tvornice modela \texttt{UserFactory} koji prikazuje definiciju stanja tvornice modela}, label=factoryStatesUser]
    /**
     * Indicate that the user is administrator.
     */
    public function administrator(): static
    {
        return $this->state(function (array $attributes) {
            return [
                'name' => 'Admin Admin',
                'email' => 'admin@teamstructor.test',
                'is_administrator' => true,
            ];
        });
    }
\end{lstlisting}

\paragraph{Relacije}
\label{paragraph:relations}\mbox{}\\
\indent Odnosi tj. relacije između modela definiraju se unutar samih klasa Eloquent modela kao metode. Može se ponovno pogledati sliku~\ref{fig:erDiagram} i obratiti pozornost na veze među modelima.

Model \texttt{User} definira veze prema modelima \texttt{Project}, \texttt{Post} i \texttt{Comments} kao što je vidljivo u ispisu~\ref{relationsUser}, a u osobini \texttt{HasTeams} koju model koristi definirane su veze prema modelima \texttt{Team} i \texttt{Membership} te su te metode prikazane u ispisu~\ref{relationsUserTrait}.

\begin{lstlisting}[caption={Relacije modela \texttt{User}}, label=relationsUser]
    /**
     * Get the projects created by user.
     */
    public function projects(): HasMany
    {
        return $this->hasMany(Project::class);
    }

    /**
     * Get the user's posts.
     */
    public function posts(): HasMany
    {
        return $this->hasMany(Post::class);
    }

    /**
     * Get the user's comments.
     */
    public function comments(): HasMany
    {
        return $this->hasMany(Comment::class);
    }
\end{lstlisting}

\begin{lstlisting}[caption={Relacije modela \texttt{User} koje koristi iz osobine \texttt{HasTeams}}, label=relationsUserTrait]
    /**
     * Get all of the teams the user owns.
     *
     * @return \Illuminate\Database\Eloquent\Relations\HasMany
     */
    public function ownedTeams()
    {
        return $this->hasMany(Jetstream::teamModel());
    }

    /**
     * Get all of the teams the user belongs to.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
     */
    public function teams()
    {
        return $this->belongsToMany(
                        Jetstream::teamModel(), 
                        Jetstream::membershipModel()
                    )->withPivot('role')
                    ->withTimestamps()
                    ->as('membership');
    }
\end{lstlisting}

Model \texttt{Team} definira veze prema modelu \texttt{Project}, kao što je vidljivo u ispisu~\ref{relationsTeam}, a nasljeđujući model \texttt{JetstreamTeam} definirane su veze prema modelima \texttt{User}, \\ \texttt{Membership} i \texttt{TeamInvitation} te su te metode prikazane u ispisu~\ref{relationsJetstreamTeam}.

\begin{lstlisting}[caption={Relacije modela \texttt{Team}}, label=relationsTeam]
<?php

namespace App\Models;

// ...
use Illuminate\Database\Eloquent\Relations\HasMany;
// ...
use Laravel\Jetstream\Team as JetstreamTeam;

class Team extends JetstreamTeam
{

// ...

    /**
     * Get the projects for the team.
     */
    public function projects(): HasMany
    {
        return $this->hasMany(Project::class)->latest();
    }
    
// ...
\end{lstlisting}

\begin{lstlisting}[caption={Relacije modela \texttt{Team} koje nasljeđuje od modela \texttt{JetstreamTeam}}, label=relationsJetstreamTeam]
    /**
     * Get the owner of the team.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function owner()
    {
        return $this->belongsTo(Jetstream::userModel(), 'user_id');
    }
    
    /**
     * Get all of the users that belong to the team.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
     */
    public function users()
    {
        return $this->belongsToMany(
                    Jetstream::userModel(), 
                    Jetstream::membershipModel()
                )->withPivot('role')
                ->withTimestamps()
                ->as('membership');
    }
    
    /**
     * Get all of the pending user invitations for the team.
     *
     * @return \Illuminate\Database\Eloquent\Relations\HasMany
     */
    public function teamInvitations()
    {
        return $this->hasMany(Jetstream::teamInvitationModel());
    }
\end{lstlisting}

Model \texttt{Membership} je pivotni model (između modela \texttt{Team} i \texttt{User}), a model \\ \texttt{TeamInvitation} definira vezu prema modelu \texttt{Team} kao što je prikazano u ispisu~\ref{relationsTeamInvitation}:

\begin{lstlisting}[caption={Relacije modela \texttt{TeamInvitation}}, label=relationsTeamInvitation]
    /**
     * Get the team that the invitation belongs to.
     */
    public function team(): BelongsTo
    {
        return $this->belongsTo(Jetstream::teamModel());
    }
\end{lstlisting}

Model \texttt{Project} definira veze prema modelima \texttt{Team}, \texttt{User} i \texttt{Post} vidljivo u ispisu~\ref{relationsProject}, te implementirajući \textit{interface} \texttt{HasMedia} i koristeći osobinu \\ \texttt{InteractsWithMedia} definira i vezu prema modelu \texttt{Resource} vidljivo u ispisu~\ref{relationsProjectTrait}.

\begin{lstlisting}[caption={Relacije modela \texttt{Project}}, label=relationsProject]
<?php

namespace App\Models;

// ...
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Spatie\MediaLibrary\HasMedia;
use Spatie\MediaLibrary\InteractsWithMedia;

class Project extends Model implements HasMedia
{
    // ...
    use InteractsWithMedia;
    
    // ...
    
    /**
     * Get the team that owns the project.
     */
    public function team(): BelongsTo
    {
        return $this->belongsTo(Team::class);
    }

    /**
     * Get the user that created the project.
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Get the posts for the project.
     */
    public function posts(): HasMany
    {
        return $this->hasMany(Post::class)
                    ->with(['user', 'comments'])
                    ->latest();
    }
    
// ...
\end{lstlisting}

\begin{lstlisting}[caption={Relacije modela \texttt{Project} koje koristi iz osobine \texttt{InteractsWithMedia}}, label=relationsProjectTrait]
public function media(): MorphMany
{
    return $this->morphMany(config('media-library.media_model'), 'model');
}
\end{lstlisting}

Model \texttt{Post} definira veze prema modelima \texttt{Project}, \texttt{User} i \texttt{Comment} kao što je prikazano u ispisu~\ref{relationsPost}, a model \texttt{Comment} definira veze prema modelima \texttt{Post} i \texttt{User}, prikazano u ispisu~\ref{relationsComment}.

\begin{lstlisting}[caption={Relacije modela \texttt{Post}}, label=relationsPost]
    /**
     * Get the project that owns the post.
     */
    public function project(): BelongsTo
    {
        return $this->belongsTo(Project::class);
    }

    /**
     * Get the author of the post.
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Get the comments for the post.
     */
    public function comments(): HasMany
    {
        return $this->hasMany(Comment::class)->latest();
    }
\end{lstlisting}

\begin{lstlisting}[caption={Relacije modela \texttt{Comment}}, label=relationsComment]
    /**
     * Get the post that owns the comment.
     */
    public function post(): BelongsTo
    {
        return $this->belongsTo(Post::class);
    }

    /**
     * Get the author of the comment.
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
\end{lstlisting}

Model \texttt{Resource}, nasljeđujući model \texttt{Media} iz Spatie Media Library paketa, definira vezu prema modelu \texttt{Project}, prikazano u ispisu~\ref{relationsMedia}.

\begin{lstlisting}[caption={Relacije modela \texttt{Resource} koje nasljeđuje od modela \texttt{Media}}, label=relationsMedia]
public function model(): MorphTo
{
    return $this->morphTo();
}
\end{lstlisting}

U ovim prethodno navedenim odnosima među modelima može se primijetiti da su korištene Eloquent relacije \texttt{HasMany} i inverzna joj \texttt{BelongsTo} - koje označavaju vezu jedan prema više (1:N) odnosno više prema jedan (N:1). Za ostvarivanje veze više prema više (N:M) korištena je Eloquent relacija \texttt{BelongsToMany}. Također su korištene i polimorfne Eloquent relacije \texttt{MorphMany} i inverzna joj \texttt{MorphTo} - koje označavaju polimofnu vezu (neovisnu o tipu modela) jedan prema više (1:N) odnosno više prema jedan (N:1)~\cite{relationships}.

\paragraph{Kolekcije}\mbox{}\\
\indent U Laravelu postoji bazna klasa \texttt{Illuminate\textbackslash Support\textbackslash Collection} koja pruža praktičan \textit{wrapper} (omotač) za rad s nizovima podataka. Eloquent upiti tj. sve Eloquent metode koje vraćaju više od jednog rezultata vraćaju instancu klase \\ \texttt{Illuminate\textbackslash Database\textbackslash Eloquent\textbackslash Collection}. Objekt Eloquent kolekcija nasljeđuje baznu Laravel kolekciju pa tako nasljeđuje i sve metode dosupne u baznoj klasi~\cite{eloquentCollections}.

Neke od najkorištenijih metoda su \texttt{all}, \texttt{count}, \texttt{dd}, \texttt{dump}, \texttt{except}, \texttt{find},\texttt{first}, \texttt{firstOrFail}, \texttt{get}, \texttt{only}, \texttt{pop}, \texttt{push}, \texttt{sortBy}, \texttt{sortByDesc}, \texttt{toArray}, \texttt{toJson}, \texttt{where}, \texttt{whereBetween}, \texttt{whereIn} itd.~\cite{collections}

\subsection{Usmjerivanje zahtjeva (engl. \textit{routing})}
Sve rute u Laravel aplikaciji definirane su unutar datoteka koje se nalaze unutar direktorija \texttt{routes}. Te su datoteke automatski učitane zahvaljujući \\ \texttt{App\textbackslash Providers\textbackslash RouteServiceProvider}. U datoteci \texttt{routes/web.php} definirane su rute korištene na aplikacijskom web sučelju, koje se mogu dohvatiti unosom URL-a u web preglednik. Rutama iz \texttt{routes/web.php} dodijeljena je \texttt{web} \textit{middleware} grupa koja pruža značajke kao što su stanje sesija i CSRF (engl. \textit{Cross-Site Request Forgery}) zaštita~\cite{routing}.

Ispis~\ref{routes} prikazuje sadržaj datoteke \texttt{routes/web.php} gdje je vidljiv način na koji su rute definirane. Podijeljene su prvenstveno u dvije grupe - prva dostupna svim prijavljenim korisnicima (grupa koristi \textit{middleware} koji zahtijeva autentikaciju), te druga dostupna samo admin korisnicima (korišten \textit{custom} \textit{middleware} \texttt{can:admin-privileges}), a zadnja defnirana ruta je ona koju koristi kontoler pri promjeni jezika aplikacije o čemu će biti riječi u poglavlju~\ref{subsection:localization}. Svakoj ruti dodijeljeno je jedinstveno ime koristeći metodu \texttt{name}.

\begin{lstlisting}[caption={Sadržaj datoteke \texttt{routes/web.php}}, label=routes, escapechar=|]
<?php

use App\Http\Controllers\LanguageController;
use App\Http\Livewire\Admin\ShowProjects as AdminShowProjects;
use App\Http\Livewire\Admin\ShowTeams;
use App\Http\Livewire\Admin\ShowUsers;
use App\Http\Livewire\Media\ShowResources;
use App\Http\Livewire\Posts\ShowPosts;
use App\Http\Livewire\Projects\ShowProjects;
use Illuminate\Support\Facades\Route;

/*
|------------------------------------------------------------------------
| Web Routes
|------------------------------------------------------------------------
|
| Here is where you can register web routes for your application. These
| routes are loaded by the RouteServiceProvider and all of them will
| be assigned to the "web" middleware group. Make something great!
|
 */

Route::middleware([
    'auth:sanctum',
    config('jetstream.auth_session'),
    'verified',
])->group(function () {
    Route::get('/', function () {
        return view('dashboard');
    })->name('dashboard');

    Route::get('teams/{team}/projects', ShowProjects::class)
        ->name('teams.projects');

    Route::get('teams/{team}/projects/{project}/discussion', ShowPosts::class)
        ->name('teams.projects.discussion');

    Route::get('teams/{team}/projects/{project}/resources', ShowResources::class)
        ->name('teams.projects.resources');
});

Route::group([
    'prefix' => 'admin',
    'middleware' => ['auth:sanctum', 'can:admin-privileges'],
], function () {
    Route::get('/', function () {
        return view('admin-dashboard');
    })->name('admin.dashboard');

    Route::get('/users', ShowUsers::class)
        ->name('admin.dashboard.users');

    Route::get('/teams', ShowTeams::class)
        ->name('admin.dashboard.teams');

    Route::get('/projects', AdminShowProjects::class)
        ->name('admin.dashboard.projects');
});

Route::get('locale/{locale}', [LanguageController::class, 'switchLocale']) |\label{line:locale.switch}|
    ->name('locale.switch');

\end{lstlisting}


Izvršavanjem Artisan naredbe \texttt{route:list} mogu se izlistati sve rute definirane u aplikaciji te je rezultat izvršavanja iste prikazan na slici~\ref{fig:routes}.
\begin{figure}[H]
	\includegraphics[width=0.9\linewidth,clip=]{assets/routes.png}
	\centering
	\caption{Izlist svih ruta definiranih u aplikaciji pomoću  Artisan naredbe \texttt{route:list}}
	\label{fig:routes}
\end{figure}

\subsection{\textit{Middleware}}
\textit{Middleware}, srednji sloj Laravel web aplikacije, mehanizam je za pregled, filtriranje i kontrolu korisničkih HTTP zahtjeva koji dolaze aplikaciji. Nekoliko \textit{middlewarea} zadano je uključeno u razvojni okvir Laravel, uključujući onaj za autentikaciju i CSRF zaštitu. Sve \textit{middleware} klase nalaze se u direktoriju \texttt{app/Http/Middleware} te se novi \textit{middleware} može stvoriti Artisan naredbom \texttt{make:middleware}~\cite{middleware}.

U ispisu~\ref{configureLocaleMiddleware} prikazan je \texttt{ConfigureLocale} \textit{middleware} napisan za potrebe implementacije lokalizacije.

\begin{lstlisting}[caption={\textit{Middleware} \texttt{ConfigureLocale}}, label=configureLocaleMiddleware]
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Session;
use Symfony\Component\HttpFoundation\Response;

class ConfigureLocale
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        if ($request->has('locale')) {
            $locale = $request->get('locale');
            Session::put('locale', $locale);
        }

        if (Session::has('locale') && array_key_exists(Session::get('locale'), config('locales'))) {
            App::setLocale(Session::get('locale'));
        } else {
            App::setLocale(config('app.fallback_locale'));
        }

        return $next($request);
    }
}

\end{lstlisting}

Pojedini \textit{middleware} treba se registrirati u aplikaciji - ako se želi da je aktivan globalno dodaje ga se među vrijednosti podatkovnog člana \texttt{\$middleware} klase \\ \texttt{app/Http/Kernel.php}, a ako se želi da djeluje na pojedinoj ruti na nju ga se dodaje pomoću metode \texttt{middleware}. Radi jednostavnosti i praktičnosti, unutar klase \\ \texttt{app/Http/Kernel.php} u podatkovnom članu \texttt{\$middlewareAliases} pojedinom \textit{middlewareu} se može nadjenuti \textit{alias} ime~\cite{middleware} (pogledati ispis~\ref{middlewareAliases}).

\begin{lstlisting}[caption={Definiranje \textit{middleware} \textit{aliasa}}, label=middlewareAliases]
    /**
     * The application's middleware aliases.
     *
     * Aliases may be used to conveniently assign middleware to routes and groups.
     *
     * @var array<string, class-string|string>
     */
    protected $middlewareAliases = [
        'auth' => \App\Http\Middleware\Authenticate::class,
        'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
        'auth.session' => \Illuminate\Session\Middleware\AuthenticateSession::class,
        'cache.headers' => \Illuminate\Http\Middleware\SetCacheHeaders::class,
        'can' => \Illuminate\Auth\Middleware\Authorize::class,
        'guest' => \App\Http\Middleware\RedirectIfAuthenticated::class,
        'password.confirm' => \Illuminate\Auth\Middleware\RequirePassword::class,
        'signed' => \App\Http\Middleware\ValidateSignature::class,
        'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
        'verified' => \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,
        'locale' => \App\Http\Middleware\ConfigureLocale::class,
    ];
\end{lstlisting}

Različite \textit{middleware} klase može se međusobno grupirati pod istim ključem (engl. \textit{key}) u prethodno navedenoj \texttt{Kernel} klasi  koristeći podatkovni član \texttt{\$middlewareGroups}~\cite{middleware} (pogledati ispis~\ref{middlewareGroups}).

\begin{lstlisting}[caption={Definiranje \textit{middleware} grupa}, label=middlewareGroups]
    /**
     * The application's route middleware groups.
     *
     * @var array<string, array<int, class-string|string>>
     */
    protected $middlewareGroups = [
        'web' => [
            \App\Http\Middleware\EncryptCookies::class,
            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
            \Illuminate\Session\Middleware\StartSession::class,
            \App\Http\Middleware\ConfigureLocale::class,
            \Illuminate\View\Middleware\ShareErrorsFromSession::class,
            \App\Http\Middleware\VerifyCsrfToken::class,
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
        ],

        'api' => [
            // \Laravel\Sanctum\Http\Middleware\EnsureFrontendRequestsAreStateful::class,
            \Illuminate\Routing\Middleware\ThrottleRequests::class.':api',
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
        ],
    ];
\end{lstlisting}

\subsection{Autentikacija}
Početni komplet Laravel Jetstream u potpunosti se pobrinuo za cjelokupan autentikacijski sustav aplikacije na način da koristi autentikacijske servise Laravel Fortifyja, uz to pruživši robustan i moderan \textit{scaffolding} korisničkog sučelja. Laravel autentikacijskim servisima može se pristupiti putem fasade (engl. \textit{facade}) \texttt{Auth}~\cite{authentication}.

Na slici~\ref{fig:register} prikazano je pristupanje ruti \texttt{register} unutar web preglednika, a na slici~\ref{fig:login} ruti \texttt{login}.
\begin{figure}[H]
	\includegraphics[width=1\linewidth,clip=]{assets/register.png}
	\centering
	\caption{\texttt{/register}}
	\label{fig:register}
\end{figure}

\begin{figure}[H]
	\includegraphics[width=1\linewidth,clip=]{assets/login.png}
	\centering
	\caption{\texttt{/login}}
	\label{fig:login}
\end{figure}

\subsection{Autorizacija}
U Laravelu postoje dva osnovna načina na koji se autoriziraju akcije - koristeći vrata (engl. \textit{gates}) ili koristeći politike (engl. \textit{policies}). Vrata je najbolje primjenjivati za autorizaciju akcija koje nisu vezane uz model ili resurs već su općenite za cijelu aplikaciju, a politike su namijenjene za autorizaciju akcija nad određenim modelom/resursom~\cite{authorization}.

\subsubsection{Vrata}
Vrata (engl. \textit{gates}) određuju ima li korisnik ovlasti za izvršavanje određene radnje. Obično se definiraju unutar \texttt{boot} metode u klasi \\ {\texttt{App\textbackslash Providers\textbackslash AuthServiceProvider}} koristeći fasadu \texttt{Gate}~\cite{authorization}.

U ispisu~\ref{gatesAdmin} prikazana je \texttt{boot} metoda u kojoj se definiraju vrata \\ \texttt{'admin-privileges'} te se koristeći metodu \texttt{before} definira \textit{closure} koji će biti provjeravan prije svih ostalih autorizacijskih provjera.

\begin{lstlisting}[caption={Vrata korištena za implementaciju admin korisnika i administratorskog sučelja}, label=gatesAdmin]
    /**
     * Register any authentication / authorization services.
     */
    public function boot(): void
    {
        $this->registerPolicies();

        Gate::define('admin-privileges', function ($user) {
            return $user->isAdministrator()
                ? Response::allow()
                : Response::deny(__('You must be an administrator.'));
        });

        Gate::before(function (User $user, string $ability) {
            if ($user->isAdministrator()) {
                return true;
            }
        });
    }
\end{lstlisting}

\subsubsection{Politike}
Politike (engl. \textit{policies}) su klase čija je zadaća organizacija autorizacijske logike pojedinog modela/resursa. Generiraju se pozivom Artisan naredbe \texttt{make:policy} te se nalaze unutar direktorija \texttt{app/Policies}. Kreirane politike potrebno je registrirati unutar podatkovnog člana \texttt{\$policies} klase {\texttt{App\textbackslash Providers\textbackslash AuthServiceProvider}}  (prikazano u ispisu~\ref{policies}) gdje se mapira pojedine Eloquent modele s odgovarajućom politikom~\cite{authorization}.

\begin{lstlisting}[caption={Registriranje politika}, label=policies]
    /**
     * The policy mappings for the application.
     *
     * @var array<class-string, class-string>
     */
    protected $policies = [
        Team::class => TeamPolicy::class,
        Project::class => ProjectPolicy::class,
        Post::class => PostPolicy::class,
        Comment::class => CommentPolicy::class,
        Resource::class => ResourcePolicy::class,
    ];
\end{lstlisting}

Kao primjer politike u ispisu~\ref{postPolicy} prikazana je datoteka \texttt{PostPolicy.php} tj. politika koja definira autorizaciju akcija nad modelom \texttt{Post}. Tu je definirano da pojedinu objavu mogu vidjeti samo članovi tima kojem objava pripada, također da objavu može urediti i ažurirati samo onaj korisnik koji ju je i objavio, a ovlasti za izbrisati objavu imaju vlasnik tima, vlasnik/tvorac projekta kojem objava pripada te autor objave.

\begin{lstlisting}[caption={Politika za autorizaciju akcija nad modelom \texttt{Post}}, label=postPolicy]
<?php

namespace App\Policies;

use App\Models\Post;
use App\Models\User;

class PostPolicy
{
    /**
     * Determine whether the user can view any models.
     */
    public function viewAny(User $user): bool
    {
        return true;
    }

    /**
     * Determine whether the user can view the model.
     */
    public function view(User $user, Post $post): bool
    {
        return $user->belongsToTeam($post->project->team);
    }

    /**
     * Determine whether the user can create models.
     */
    public function create(User $user): bool
    {
        return true;
    }

    /**
     * Determine whether the user can update the model.
     */
    public function update(User $user, Post $post): bool
    {
        return $post->user->id == $user->id;
    }

    /**
     * Determine whether the user can delete the model.
     */
    public function delete(User $user, Post $post): bool
    {
        return $user->ownsTeam($post->project->team) ||
            $user->ownsProject($post->project) ||
            $post->user->id == $user->id;
    }

    /**
     * Determine whether the user can restore the model.
     */
    public function restore(User $user, Post $post): bool
    {
        return false;
    }

    /**
     * Determine whether the user can permanently delete the model.
     */
    public function forceDelete(User $user, Post $post): bool
    {
        return false;
    }
}

\end{lstlisting}

Za provjeru korisnikovih ovlasti za izvršenje pojedine akcije nad modelom/resursom koristi se metoda \texttt{authorize}, a unutar Blade predložaka koriste se još i direktive \texttt{@can}, \texttt{@cannot}, \texttt{@canany}~\cite{authorization}.

\subsection{Livewire komponente}
Livewire je \textit{full-stack} razvojni okvir za Laravel koji olakšava razvijanje dinamičkog korisničkog sučelja. Razvio ga je Caleb Porzio, otvorenog je k\^oda te je k\^od dostupan na platformi GitHub~\cite{livewireGithub}. Radi na način da se prvo inicijalno prikazuje Livewire komponenta na stranici, a zatim kada korisnik s njom interaktira Livewire šalje AJAX zahtjev prema serveru s ažuriranim podatcima. Server zatim iznova prikazuje tu komponentu i vraća novi HTML, a Livewire mutira DOM (engl. \textit{Document Object Model}) tako da se učinjene promjene očitaju na stranici~\cite{livewire}.

Livewire komponenta kreira se pozivom Artisan naredbe \texttt{make:livewire} te će se tada kreirati sljedeće dvije datoteke - u direktoriju \texttt{app/Http/Livewire} kreirat će se klasa Livewire komponente, a u direktoriju \texttt{resources/views/livewire} \texttt{.blade.php} datoteka Livewire komponente. U ispisu~\ref{showPostClass} prikazana je klasa Livewire komponente \texttt{ShowPost}.

\begin{lstlisting}[caption={\texttt{ShowPost.php} - klasa Livewire komponente}, label=showPostClass]
<?php

namespace App\Http\Livewire\Posts;

// use ... -> required imports 

class ShowPost extends Component
{
    use AuthorizesRequests;
    use InteractsWithBanner;

    public Post $post;
    public $postId;
    public $title;
    public $content;
    public $openEditModal;
    public $openDeleteModal;

    protected $listeners = ['postUpdated' => '$refresh'];

    protected $rules = [
        'title' => 'required',
        'content' => 'required',
    ];

    public function render()
    {
        return view('livewire.posts.show-post');
    }

    public function edit($id)
    {
        $post = Post::findOrFail($id);

        $this->authorize('update', $post);

        $this->postId = $id;
        $this->title = $post->title;
        $this->content = $post->content;

        $this->openEditModal = true;
    }

    public function update()
    {
        $this->validate();

        if ($this->postId) {
            Post::find($this->postId)->update([
                'title' => $this->title,
                'content' => $this->content,
            ]);

            $this->emitSelf('postUpdated');
            $this->banner(__('Post updated successfully.'));

            $this->openEditModal = false;

            $this->reset(['title', 'content']);
        }
    }

    public function delete($id)
    {
        $post = Post::findOrFail($id);

        $this->authorize('delete', $post);

        $this->postId = $id;

        $this->openDeleteModal = true;
    }

    public function destroy()
    {
        if ($this->postId) {
            Comment::where('post_id', $this->postId)->delete();
            Post::where('id', $this->postId)->delete();

            $this->emit('postDeleted');
            $this->banner(__('Post deleted successfully.'));

            $this->openDeleteModal = false;
        }
    }
}

\end{lstlisting}

Livewire komponenta može biti uključena u Blade predložak koristeći direktivu \\ \texttt{@livewire}.

Validacija atributa komponente u Livewireu obavlja se pozivom metode \\ \texttt{\$this->validate()} koja zatim provjerava pravila definirana unutar podatkovnog člana \texttt{\$rules} za pojedini atribut~\cite{livewireValidation}.

Kako bi se unutar Livewire komponente koristila paginacija potrebno je da komponenta koristi osobinu (engl. \textit{trait}) \texttt{WithPagination}~\cite{livewirePagination}.

\subsubsection{Akcije}
Akcije u Livewireu "osluškuju" interakcije na stranici te pozivaju odgovarajuću metodu na Livewire komponenti~\cite{livewireActions}.

Tako, gledajući prethodni ispis, metode \texttt{edit}, \texttt{update}, \texttt{delete}, \texttt{destroy} u klasi Livewire komponente izvršavaju se nakon interakcije korisnika nad određenim elementom na stranici - primjerice korisnik interaktira s gumbom (engl. \textit{button}) koji "osluškuje" određeni događaj putem direktive \texttt{wire} kao npr. \texttt{wire:click="edit"}, \\ \texttt{wire:click="update"},  \texttt{wire:click="delete"}, \texttt{wire:click="destroy"} u pripadajućem Blade predlošku.

Kako bi se akcije u Livewireu mogle autorizirati potrebno je da Livewire komponenta koristi osobinu (engl. \textit{trait}) \texttt{AuthorizesRequests} te je zatim moguće pozvati metodu \texttt{\$this->authorize()} unutar Livewire komponente~\cite{livewireAuthorization}. 

\subsubsection{Događaji}
Livewire komponente koje "žive" na istoj stranici međusobno mogu komunicirati putem globalnog sustava događaja~\cite{livewireEvents}.

Događaji se mogu pokrenuti na više načina: iz Blade predloška, iz komponente te iz globalnog JavaScripta pozivom neke od sljedećih metoda: \texttt{emit}, \texttt{emitUp}, \texttt{emitTo}, \texttt{emitSelf}, ovisno o \textit{scopeu} unutar kojega će emitirani događaj biti dostupan~\cite{livewireEvents}.

Unutar klase Livewire komponente i to u podatkovnom članu \texttt{\$listeners} potrebno je registrirati koje će događaje komponenta "slušati" te koju metodu će komponenta pozvati kad se određeni događaj emitira~\cite{livewireEvents}. 

\subsection{Pohrana datoteka}
Laravel integrira Flysystem~\cite{flysystemGitHub} PHP paket Franka de Jongea te tako pruža apstrakciju datotečnog sustava - nudi \textit{drivere} za rad s lokalnim datotečnim sustavom, SFTP-om (engl. \textit{Secure File Transfer Protocol}) te Amazon S3 pohranom objekata u oblaku~\cite{fileStorage}.

Konfiguracijska datoteka datotečnog sustava u Laravelu jest \texttt{filesystems.php} unutar direktorija \texttt{config} te se u njoj konfiguriraju tzv. diskovi Laravel datotečnog sustava od kojih svaki predstavlja jedinstveni \textit{driver} te lokaciju za pohranu. \textit{Driver} \texttt{local} upravlja datotekama pohranjenima na lokalnom serveru na kojemu se pokreće Laravel aplikacija, a \textit{driver} \texttt{s3} koristi se za pohranu datoteka na Amazon S3 pohranu objekata u oblaku~\cite{fileStorage}. 

\subsubsection{MinIO - AWS S3 kompatibilan servis za pohranu}
U aplikaciji \textit{Teamstructor} za pohranu timskih resursa korišten je AWS (Amazon Web Services) S3 kompatibilan servis za pohranu naziva \textbf{MinIO}~\cite{minio}. On koristi \texttt{s3} disk u konfiguracijskoj datoteci.

Prije korištenja \texttt{s3} \textit{drivera} potrebno je instalirati Flysystem S3 paket putem Composera pozivom naredbe: \texttt{composer require league/flysystem-aws-s3-v3 "\textasciicircum 3.0" -{}-with-all-dependencies}~\cite{fileStorage}. Također je potrebno dodati MinIO servis u \texttt{docker-compose.yml} datoteku kao što je prikazano u ispisu~\ref{minioDocker} te definirati potrebne \textit{environment} varijable unutar \texttt{.env} datoteke kao u ispisu~\ref{minioEnv}.

\begin{lstlisting}[caption={\texttt{minio} servis unutar \texttt{docker-compose.yml} datoteke}, label=minioDocker]
version: "3.9"
services:
  # ...
  
  minio:
    image: minio/minio
    ports:
      - 9000:9000
      - 9001:9001
    environment:
        MINIO_ROOT_USER: minioadmin
        MINIO_ROOT_PASSWORD: minioadmin
    volumes:
        - minio-data:/data
    command: server /data --console-address :9001

  # ...
  
volumes:
  # ...
  minio-data:

\end{lstlisting}

\begin{lstlisting}[caption={Definiranje potrebnih AWS/MinIO \textit{environment} varijabli}, label=minioEnv]
AWS_ACCESS_KEY_ID=XXXXXXXXXXXXXXXXXXXX
AWS_SECRET_ACCESS_KEY=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
AWS_DEFAULT_REGION=eu-south-1
AWS_BUCKET=teamstructor-bucket
AWS_URL=http://teamstructor.test:9000/teamstructor-bucket
AWS_ENDPOINT=http://minio:9000
AWS_USE_PATH_STYLE_ENDPOINT=true
\end{lstlisting}

Pristupajući URL-u \url{http://localhost:9000} unutar web preglednika prikazat će se MinIO Object Store zaslon za prijavu kao na slici~\ref{fig:minioLogin}, a uspješnom prijavom koristeći korisničko ime i lozinku definirane za \texttt{minio} Docker spremnik prikazat će se Object Browser zaslon prikazan na slici~\ref{fig:minioObjectBrowser} na kojemu je moguće pregledati i pristupiti pojedinim \textit{bucketima}~\cite{minioContainer}.
\begin{figure}[H]
	\includegraphics[width=1\linewidth,clip=]{assets/minio-login.png}
	\centering
	\caption{MinIO Console - MinIO Object Store \textit{login} zaslon}
	\label{fig:minioLogin}
\end{figure}

\begin{figure}[H]
	\includegraphics[width=1\linewidth,clip=]{assets/minio-object-browser.png}
	\centering
	\caption{MinIO Console - MinIO Object Browser zaslon i stvoreni \textit{bucket}}
	\label{fig:minioObjectBrowser}
\end{figure}

\subsection{Spatie Laravel Media Library paket}
Za implementaciju timskih resursa korišten je Laravel Media Library \\ (\texttt{spatie/laravel-medialibrary}) paket razvijen od strane Spatie tima - belgijske \textit{development} agencije koja razvija mnogo poznatih paketa otvorenog k\^oda za PHP i Laravel ekosustav.

Media Library paket instalira se putem Composera naredbom \texttt{composer require "spatie/laravel-medialibrary:\textasciicircum 10.0.0"} te je potom potrebno objaviti migraciju za kreiranje tablice \texttt{media} pomoću Artisan naredbe \texttt{vendor:publish} te primijeniti tu migraciju na bazu podataka~\cite{mediaLibrary}.

Za ostvariti željenu vezu između modela \texttt{Project} i \texttt{Resource} potrebno je da model \texttt{Project} implementira \textit{interface} \texttt{HasMedia} i osobinu (engl. \textit{trait}) \\ \texttt{InteractsWithMedia}, a model \texttt{Resource} nasljeđuje bazni model \texttt{Media} iz Media Library paketa. Također je potrebno u konfiguracijskoj datoteci \\ \texttt{config/media-library.php} navesti naziv klase \textit{custom} medijskog modela kao u ispisu~\ref{mediaModelConfig}.

\begin{lstlisting}[caption={Specificiranje naziva klase \textit{media} modela u \texttt{config/media-library.php}}, label=mediaModelConfig]
    /*
     * The fully qualified class name of the media model.
     */
    'media_model' => App\Models\Resource::class,
\end{lstlisting}

U ispisu~\ref{uploadResource} vidljiv je dio k\^oda zaslužan za asociranje učitanog resursa s pripadajućim projektom te pohranjivanje učitanog resursa na \texttt{s3} disk. U prikazanoj metodi \texttt{save} iz klase Livewire komponente \texttt{UploadResource} prvo se validira \textit{input} tj. učitana datoteka, zatim se koristeći metodu \texttt{addMedia} učitani resurs asocira s pripadajućim projektom. Pozivom metode \texttt{toMediaCollection} resurs se pohranjuje na \texttt{s3} disk u zadanu medijsku kolekciju, a pozivom metode \texttt{withCustomProperties} na resurs se dodaje i  \textit{custom} svojstvo \texttt{'user\_id'} gdje spremamo identifikator korisnika koji je izvršio \textit{upload} te datoteke.

\begin{lstlisting}[caption={Asociranje resursa s pripadajućim projektom i njegovo pohranjivanje koristeći Media Library metode}, label=uploadResource]
    public function save()
    {
        $this->validate([
            'resource' => 'required|file|max:12288', // (12MB max)
        ]);

        $this->project
            ->addMedia($this->resource)
            ->withCustomProperties(['user_id' => Auth::user()->id])
            ->toMediaCollection('default', 's3');

        $this->emit('resourceAdded');
        $this->banner(__('Resource uploaded successfully.'));

        $this->reset(['resource']);
    }
\end{lstlisting}

\subsection{Lokalizacija}
\label{subsection:localization}
Zadano Laravel aplikacija ne sadrži direktorij \texttt{lang} u kojem bi bile pohranjene potrebne jezične datoteke, ali ga se može stvoriti izvođenjem Artisan naredbe \\ \texttt{lang:publish}~\cite{localization}. 

Lokalizacija \textit{Teamstructor} aplikacije izvedena je na način da su podržani engleski i hrvatski jezik što je jasno naznačeno u datoteci \texttt{config/locales.php} čiji je sadržaj prikazan u ispisu~\ref{configLocales}.

\begin{lstlisting}[caption={Sadržaj datoteke \texttt{config/locales.php}}, label=configLocales]
<?php

return [
    /*
    |------------------------------------------------------------------
    | Locales
    |------------------------------------------------------------------
    |
    | List of application locales (locale_code => language_name).
    |
    */

    'en' => 'English',
    'hr' => 'Hrvatski',
];

\end{lstlisting}

Jezične JSON datoteke s prevedenim \textit{stringovima}  nalaze se u aplikacijskom direktoriju \texttt{resources/lang}:
\\
\dirtree{%
.1 resources/lang.
.2 en.json.
.2 hr.json.
}

Kako bi se doista u Blade predlošku i prikazali odgovarajući prevedeni stringovi koristi se \textit{echo} sintaksa \texttt{\{\{ \}\}} i \textit{helper} funkcija \_\_ npr. \texttt{\{\{ \_\_('Welcome to your Teamstructor application!') \}\}}~\cite{localization}.

Implementiran je \texttt{LanguageController} prikazan u ispisu~\ref{languageController}, dodana ruta za promjenu trenutnog jezika (prikazano u ispisu~\ref{routes} u liniji~\ref{line:locale.switch}), dodan \texttt{ConfigureLocale} \textit{middleware} prikazan u ispisu~\ref{configureLocaleMiddleware}.

\begin{lstlisting}[caption={\texttt{LanguageContoller.php}}, label=languageController]
<?php

namespace App\Http\Controllers;

use Illuminate\Support\Facades\Redirect;
use Illuminate\Support\Facades\Session;

class LanguageController extends Controller
{
    public function switchLocale($locale)
    {
        if (array_key_exists($locale, config('locales'))) {
            Session::put('locale', $locale);
        }

        return Redirect::back();
    }
}

\end{lstlisting}

U konfiguracijsku datoteku za NGINX server \texttt{default.conf} dodana je linija \\ \texttt{rewrite \textasciicircum /(en|hr)/?(.*)?  https://teamstructor.test/\$2?locale=\$1 \\ permanent;}, te u \texttt{.htaccess} datoteku linija \\ \texttt{RedirectMatch "\textasciicircum /(en|hr)/?(.*)?" "/\$2?locale=\$1"} što omogućava da se u web pregledniku URL unesen u formi \url{https://teamstructor.test/hr} tumači kao \url{https://teamstructor.test/?locale=hr}.

Naposlijetku je implementiran i \textit{language switcher} tj. gumb za promjenu jezika prikazan na slici~\ref{fig:localeSwitcher}.
\begin{figure}[H]
	\includegraphics[width=0.7\linewidth,clip=]{assets/language-switcher.png}
	\centering
	\caption{Gumb u navigacijskoj traci koji služi za promjenu trenutnog jezika aplikacije}
	\label{fig:localeSwitcher}
\end{figure}

\subsection{Testiranje i kvaliteta k\^oda}

\subsubsection{Korišteni alati}
Pri \textit{developmentu} radi bržeg otkrivanja i otklanjanja pogrešaka te praćenja performansi i ponašanja u aplikaciji korišteni su paketi \textbf{Laravel Debug Bar}~\cite{laravelDebugbarGitHub} i \textbf{Laravel Telescope}~\cite{telescope}.

Također je korišten i \textit{code style fixer} \textbf{Laravel Pint}~\cite{pint}, izgrađen na PHP-CS-Fixeru, koji je automatski dostupan za korištenje uz Laravel instalaciju. Pomaže da k\^od ostane "čist" i konzistentan te se popravak \textit{code stylea} inicira izvođenjem naredbe \\ \texttt{.vendor/bin/pint} iz terminala. 

Radi pretpregleda testne elektroničke pošte u aplikaciji (poslane i primljene) dodan je servis \textbf{MailHog}~\cite{mailhogGitHub} u datoteku \texttt{docker-compose.yml} (prikazano u ispisu~\ref{mailhog}) te se MailHog web sučelju može pristupiti unosom URL-a \url{http://localhost:8025} u web preglednik.

\begin{lstlisting}[caption={\texttt{mailhog} servis unutar \texttt{docker-compose.yml} datoteke}, label=mailhog]
  mailhog:
    platform: linux/x86_64
    image: mailhog/mailhog
    ports:
      - 1025:1025 # smtp server
      - 8025:8025 # web ui
\end{lstlisting}

\subsubsection{Pisanje i pokretanje testova}
U aplikacijskom \texttt{test} direktoriju zadano se nalaze dva poddirektorija - \texttt{Feature} i \texttt{Unit}. \textit{Unit} testovi testiraju mali izolirani dio k\^oda, a \textit{feature} testovi testiraju veće dijelove k\^oda tj. pojedine funkcionalnosti u cijelosti~\cite{testing}.

Kako se testiranje ne bi provodilo nad glavnom "radnom" bazom podataka i tako se vršile promjene nad stvarnim zapisima u bazi, za potrebe testiranja definirano je posebno izolirano \texttt{sqlite\_testing} okruženje baze podataka u memoriji (prikazano u ispisu~\ref{sqliteTesting}).

\begin{lstlisting}[caption={Testno okruženje baze podataka definirano u \texttt{config/database.php}}, label=sqliteTesting]
        'sqlite_testing' => [
            'driver' => 'sqlite',
            'database' => ':memory:',
        ],
\end{lstlisting}

Laravel automatski dolazi s podrškom za testiranje s \textbf{PHPUnitom} te se novi \textit{feature} test može kreirati pozivom Artisan naredbe \texttt{make:test}, a testovi se mogu pokrenuti koristeći \texttt{phpunit} naredbu \texttt{./vendor/bin/phpunit} ili Artisan naredbu \texttt{test}~\cite{testing}.

U ispisu~\ref{phpunitTest} prikazan je primjer \textit{feature} testa pisanog u PHPUnitu.

\begin{lstlisting}[caption={\texttt{CreateCommentFormTest} - \texttt{test\_the\_component\_can\_render}}, label=phpunitTest]
<?php

namespace Tests\Feature;

// use ... -> imports

class CreateCommentFormTest extends TestCase
{
    use RefreshDatabase;

    public function test_the_component_can_render(): void
    {
        $this->actingAs($user = User::factory()->withPersonalTeam()->create());

        $project = Project::factory()->create([
            'team_id' => $user->currentTeam,
            'user_id' => $user,
        ]);

        $post = Post::factory()->create([
            'project_id' => $project,
            'user_id' => $user,
        ]);

        $component = Livewire::test(CreateCommentForm::class, ['post' => $post]);

        $component->assertStatus(200);
    }
}

\end{lstlisting}

\textbf{Pest} PHP razvojno okruženje za testiranje potrebno je instalirati putem Composera: \texttt{composer require pestphp/pest -{}-dev -{}-with-all-dependencies}, \\ a zatim inicijalizirati Pest u trenutnom projektu koristeći naredbu \\ \texttt{./vendor/bin/pest -{}-init}~\cite{pestInstallation}.

Moguće je instalirati Pest dodatke (engl. \textit{plugins}) za Laravel i Livewire putem Composera: \texttt{composer require pestphp/pest-plugin-laravel -{}-dev} i \\ \texttt{composer require pestphp/pest-plugin-livewire -{}-dev}~\cite{pestPlugins}.

Testovi se nakon instalacije Pesta mogu pokretati naredbom \texttt{./vendor/bin/pest}, a Pest test može se kreirati pozivom Artisan naredbe \texttt{pest:test}~\cite{pestInstallation}.

U ispisu~\ref{pestTest} prikazan je primjer \textit{feature} testa pisanog u Pestu.

\begin{lstlisting}[caption={\texttt{UploadResourceTest} - \texttt{test 'the component can render'}}, label=pestTest]
<?php

// use ... -> imports

uses()->group('feature', 'resources');

uses(RefreshDatabase::class);

test('the component can render', function () {
    actingAs($user = User::factory()->withPersonalTeam()->create());

    $project = Project::factory()->create([
        'team_id' => $user->currentTeam,
        'user_id' => $user,
    ]);

    livewire(UploadResource::class, ['project' => $project])
        ->assertStatus(200);
});

\end{lstlisting}

\subsection{Otvoreni k\^od i doprinos zajednice na projektima Laravel ekosustava}
